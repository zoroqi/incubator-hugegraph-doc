<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HugeGraph – PERFORMANCE</title><link>/docs/performance/</link><description>Recent content in PERFORMANCE on HugeGraph</description><generator>Hugo -- gohugo.io</generator><atom:link href="/docs/performance/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: HugeGraph BenchMark Performance</title><link>/docs/performance/hugegraph-benchmark-0.5.6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/performance/hugegraph-benchmark-0.5.6/</guid><description>
&lt;h3 id="1-test-environment">1 Test environment&lt;/h3>
&lt;h4 id="11-hardware-information">1.1 Hardware information&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>CPU&lt;/th>
&lt;th>Memory&lt;/th>
&lt;th>网卡&lt;/th>
&lt;th>磁盘&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>48 Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz&lt;/td>
&lt;td>128G&lt;/td>
&lt;td>10000Mbps&lt;/td>
&lt;td>750GB SSD&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="12-software-information">1.2 Software information&lt;/h4>
&lt;h5 id="121-test-cases">1.2.1 Test cases&lt;/h5>
&lt;p>Testing is done using the &lt;a href="https://github.com/socialsensor/graphdb-benchmarks">graphdb-benchmark&lt;/a>, a benchmark suite for graph databases. This benchmark suite mainly consists of four types of tests:&lt;/p>
&lt;ul>
&lt;li>Massive Insertion, which involves batch insertion of vertices and edges, with a certain number of vertices or edges being submitted at once.&lt;/li>
&lt;li>Single Insertion, which involves the immediate insertion of each vertex or edge, one at a time.&lt;/li>
&lt;li>Query, which mainly includes the basic query operations of the graph database:
&lt;ul>
&lt;li>Find Neighbors, which queries the neighbors of all vertices.&lt;/li>
&lt;li>Find Adjacent Nodes, which queries the adjacent vertices of all edges.&lt;/li>
&lt;li>Find Shortest Path, which queries the shortest path from the first vertex to 100 random vertices.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Clustering, which is a community detection algorithm based on the Louvain Method.&lt;/li>
&lt;/ul>
&lt;h5 id="122-test-dataset">1.2.2 Test dataset&lt;/h5>
&lt;p>Tests are conducted using both synthetic and real data.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>MIW, SIW, and QW use SNAP datasets:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://snap.stanford.edu/data/email-Enron.html">Enron Dataset&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://snap.stanford.edu/data/amazon0601.html">Amazon dataset&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://snap.stanford.edu/data/com-Youtube.html">Youtube dataset&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://snap.stanford.edu/data/com-LiveJournal.html">LiveJournal dataset&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>CW uses synthetic data generated by the &lt;a href="https://sites.google.com/site/andrealancichinetti/files">LFR-Benchmark generator&lt;/a>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The size of the datasets used in this test are not mentioned.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Number of Vertices&lt;/th>
&lt;th>Number of Edges&lt;/th>
&lt;th>File Size&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>email-enron.txt&lt;/td>
&lt;td>36,691&lt;/td>
&lt;td>367,661&lt;/td>
&lt;td>4MB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>com-youtube.ungraph.txt&lt;/td>
&lt;td>1,157,806&lt;/td>
&lt;td>2,987,624&lt;/td>
&lt;td>38.7MB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>amazon0601.txt&lt;/td>
&lt;td>403,393&lt;/td>
&lt;td>3,387,388&lt;/td>
&lt;td>47.9MB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>com-lj.ungraph.txt&lt;/td>
&lt;td>3997961&lt;/td>
&lt;td>34681189&lt;/td>
&lt;td>479MB&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="13-service-configuration">1.3 Service configuration&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>HugeGraph version: 0.5.6, RestServer and Gremlin Server and backends are on the same server&lt;/p>
&lt;ul>
&lt;li>RocksDB version: rocksdbjni-5.8.6&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Titan version: 0.5.4, using thrift+Cassandra mode&lt;/p>
&lt;ul>
&lt;li>Cassandra version: cassandra-3.10, commit-log and data use SSD together&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Neo4j version: 2.0.1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>The Titan version adapted by graphdb-benchmark is 0.5.4.&lt;/p>
&lt;/blockquote>
&lt;h3 id="2-test-results">2 Test results&lt;/h3>
&lt;h4 id="21-batch-insertion-performance">2.1 Batch insertion performance&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Backend&lt;/th>
&lt;th>email-enron(30w)&lt;/th>
&lt;th>amazon0601(300w)&lt;/th>
&lt;th>com-youtube.ungraph(300w)&lt;/th>
&lt;th>com-lj.ungraph(3000w)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>HugeGraph&lt;/td>
&lt;td>0.629&lt;/td>
&lt;td>5.711&lt;/td>
&lt;td>5.243&lt;/td>
&lt;td>67.033&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Titan&lt;/td>
&lt;td>10.15&lt;/td>
&lt;td>108.569&lt;/td>
&lt;td>150.266&lt;/td>
&lt;td>1217.944&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Neo4j&lt;/td>
&lt;td>3.884&lt;/td>
&lt;td>18.938&lt;/td>
&lt;td>24.890&lt;/td>
&lt;td>281.537&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Instructions&lt;/em>&lt;/p>
&lt;ul>
&lt;li>The data scale is in the table header in terms of edges&lt;/li>
&lt;li>The data in the table is the time for batch insertion, in seconds&lt;/li>
&lt;li>For example, HugeGraph(RocksDB) spent 5.711 seconds to insert 3 million edges of the amazon0601 dataset.&lt;/li>
&lt;/ul>
&lt;h5 id="conclusion">Conclusion&lt;/h5>
&lt;ul>
&lt;li>The performance of batch insertion: HugeGraph(RocksDB) &amp;gt; Neo4j &amp;gt; Titan(thrift+Cassandra)&lt;/li>
&lt;/ul>
&lt;h4 id="22-traversal-performance">2.2 Traversal performance&lt;/h4>
&lt;h5 id="221-explanation-of-terms">2.2.1 Explanation of terms&lt;/h5>
&lt;ul>
&lt;li>FN(Find Neighbor): Traverse all vertices, find the adjacent edges based on each vertex, and use the edges and vertices to find the other vertices adjacent to the original vertex.&lt;/li>
&lt;li>FA(Find Adjacent): Traverse all edges, get the source vertex and target vertex based on each edge.&lt;/li>
&lt;/ul>
&lt;h5 id="222-fn-performance">2.2.2 FN performance&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Backend&lt;/th>
&lt;th>email-enron(3.6w)&lt;/th>
&lt;th>amazon0601(40w)&lt;/th>
&lt;th>com-youtube.ungraph(120w)&lt;/th>
&lt;th>com-lj.ungraph(400w)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>HugeGraph&lt;/td>
&lt;td>4.072&lt;/td>
&lt;td>45.118&lt;/td>
&lt;td>66.006&lt;/td>
&lt;td>609.083&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Titan&lt;/td>
&lt;td>8.084&lt;/td>
&lt;td>92.507&lt;/td>
&lt;td>184.543&lt;/td>
&lt;td>1099.371&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Neo4j&lt;/td>
&lt;td>2.424&lt;/td>
&lt;td>10.537&lt;/td>
&lt;td>11.609&lt;/td>
&lt;td>106.919&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Instructions&lt;/em>&lt;/p>
&lt;ul>
&lt;li>The data in the table header &amp;ldquo;( )&amp;rdquo; represents the data scale, in terms of vertices.&lt;/li>
&lt;li>The data in the table represents the time spent traversing vertices, in seconds.&lt;/li>
&lt;li>For example, HugeGraph uses the RocksDB backend to traverse all vertices in amazon0601, and search for adjacent edges and another vertex, which takes a total of 45.118 seconds.&lt;/li>
&lt;/ul>
&lt;h5 id="223-fa性能">2.2.3 FA性能&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Backend&lt;/th>
&lt;th>email-enron(30w)&lt;/th>
&lt;th>amazon0601(300w)&lt;/th>
&lt;th>com-youtube.ungraph(300w)&lt;/th>
&lt;th>com-lj.ungraph(3000w)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>HugeGraph&lt;/td>
&lt;td>1.540&lt;/td>
&lt;td>10.764&lt;/td>
&lt;td>11.243&lt;/td>
&lt;td>151.271&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Titan&lt;/td>
&lt;td>7.361&lt;/td>
&lt;td>93.344&lt;/td>
&lt;td>169.218&lt;/td>
&lt;td>1085.235&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Neo4j&lt;/td>
&lt;td>1.673&lt;/td>
&lt;td>4.775&lt;/td>
&lt;td>4.284&lt;/td>
&lt;td>40.507&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Explanation&lt;/em>&lt;/p>
&lt;ul>
&lt;li>The data size in the header &amp;ldquo;( )&amp;rdquo; is based on the number of vertices.&lt;/li>
&lt;li>The data in the table is the time it takes to traverse the vertices, in seconds.&lt;/li>
&lt;li>For example, HugeGraph with RocksDB backend traverses all vertices in the amazon0601 dataset, and looks up adjacent edges and other vertices, taking a total of 45.118 seconds.&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h6 id="conclusion-1">Conclusion&lt;/h6>
&lt;ul>
&lt;li>Traversal performance: Neo4j &amp;gt; HugeGraph(RocksDB) &amp;gt; Titan(thrift+Cassandra)&lt;/li>
&lt;/ul>
&lt;h4 id="23-performance-of-common-graph-analysis-methods-in-hugegraph">2.3 Performance of Common Graph Analysis Methods in HugeGraph&lt;/h4>
&lt;h5 id="terminology-explanation">Terminology Explanation&lt;/h5>
&lt;ul>
&lt;li>FS (Find Shortest Path): finding the shortest path between two vertices&lt;/li>
&lt;li>K-neighbor: all vertices that can be reached by traversing K hops (including 1, 2, 3&amp;hellip;(K-1) hops) from the starting vertex&lt;/li>
&lt;li>K-out: all vertices that can be reached by traversing exactly K out-edges from the starting vertex.&lt;/li>
&lt;/ul>
&lt;h5 id="fs-performance">FS performance&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Backend&lt;/th>
&lt;th>email-enron(30w)&lt;/th>
&lt;th>amazon0601(300w)&lt;/th>
&lt;th>com-youtube.ungraph(300w)&lt;/th>
&lt;th>com-lj.ungraph(3000w)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>HugeGraph&lt;/td>
&lt;td>0.494&lt;/td>
&lt;td>0.103&lt;/td>
&lt;td>3.364&lt;/td>
&lt;td>8.155&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Titan&lt;/td>
&lt;td>11.818&lt;/td>
&lt;td>0.239&lt;/td>
&lt;td>377.709&lt;/td>
&lt;td>575.678&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Neo4j&lt;/td>
&lt;td>1.719&lt;/td>
&lt;td>1.800&lt;/td>
&lt;td>1.956&lt;/td>
&lt;td>8.530&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Explanation&lt;/em>&lt;/p>
&lt;ul>
&lt;li>The data in the header &amp;ldquo;()&amp;rdquo; represents the data scale in terms of edges&lt;/li>
&lt;li>The data in the table is the time it takes to find the shortest path &lt;strong>from the first vertex to 100 randomly selected vertices&lt;/strong> in seconds&lt;/li>
&lt;li>For example, HugeGraph using the RocksDB backend to find the shortest path from the first vertex to 100 randomly selected vertices in the amazon0601 graph took a total of 0.103s.&lt;/li>
&lt;/ul>
&lt;h6 id="conclusion-2">Conclusion&lt;/h6>
&lt;ul>
&lt;li>In scenarios with small data size or few vertex relationships, HugeGraph outperforms Neo4j and Titan.&lt;/li>
&lt;li>As the data size increases and the degree of vertex association increases, the performance of HugeGraph and Neo4j tends to be similar, both far exceeding Titan.&lt;/li>
&lt;/ul>
&lt;h5 id="k-neighbor-performance">K-neighbor Performance&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Vertex&lt;/th>
&lt;th>Depth&lt;/th>
&lt;th>Degree 1&lt;/th>
&lt;th>Degree 2&lt;/th>
&lt;th>Degree 3&lt;/th>
&lt;th>Degree 4&lt;/th>
&lt;th>Degree 5&lt;/th>
&lt;th>Degree 6&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>v1&lt;/td>
&lt;td>Time&lt;/td>
&lt;td>0.031s&lt;/td>
&lt;td>0.033s&lt;/td>
&lt;td>0.048s&lt;/td>
&lt;td>0.500s&lt;/td>
&lt;td>11.27s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>v111&lt;/td>
&lt;td>Time&lt;/td>
&lt;td>0.027s&lt;/td>
&lt;td>0.034s&lt;/td>
&lt;td>0.115s&lt;/td>
&lt;td>1.36s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;td>&amp;ndash;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>v1111&lt;/td>
&lt;td>Time&lt;/td>
&lt;td>0.039s&lt;/td>
&lt;td>0.027s&lt;/td>
&lt;td>0.052s&lt;/td>
&lt;td>0.511s&lt;/td>
&lt;td>10.96s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Explanation&lt;/em>&lt;/p>
&lt;ul>
&lt;li>HugeGraph-Server&amp;rsquo;s JVM memory is set to 32GB and may experience OOM when the data is too large.&lt;/li>
&lt;/ul>
&lt;h5 id="k-out-performance">K-out performance&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Vertex&lt;/th>
&lt;th>Depth&lt;/th>
&lt;th>1st Degree&lt;/th>
&lt;th>2nd Degree&lt;/th>
&lt;th>3rd Degree&lt;/th>
&lt;th>4th Degree&lt;/th>
&lt;th>5th Degree&lt;/th>
&lt;th>6th Degree&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>v1&lt;/td>
&lt;td>Time&lt;/td>
&lt;td>0.054s&lt;/td>
&lt;td>0.057s&lt;/td>
&lt;td>0.109s&lt;/td>
&lt;td>0.526s&lt;/td>
&lt;td>3.77s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Degree&lt;/td>
&lt;td>10&lt;/td>
&lt;td>133&lt;/td>
&lt;td>2453&lt;/td>
&lt;td>50,830&lt;/td>
&lt;td>1,128,688&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>v111&lt;/td>
&lt;td>Time&lt;/td>
&lt;td>0.032s&lt;/td>
&lt;td>0.042s&lt;/td>
&lt;td>0.136s&lt;/td>
&lt;td>1.25s&lt;/td>
&lt;td>20.62s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Degree&lt;/td>
&lt;td>10&lt;/td>
&lt;td>211&lt;/td>
&lt;td>4944&lt;/td>
&lt;td>113150&lt;/td>
&lt;td>2,629,970&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>v1111&lt;/td>
&lt;td>Time&lt;/td>
&lt;td>0.039s&lt;/td>
&lt;td>0.045s&lt;/td>
&lt;td>0.053s&lt;/td>
&lt;td>1.10s&lt;/td>
&lt;td>2.92s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Degree&lt;/td>
&lt;td>10&lt;/td>
&lt;td>140&lt;/td>
&lt;td>2555&lt;/td>
&lt;td>50825&lt;/td>
&lt;td>1,070,230&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Explanation&lt;/em>&lt;/p>
&lt;ul>
&lt;li>The JVM memory of HugeGraph-Server is set to 32GB, and OOM may occur when the data is too large.&lt;/li>
&lt;/ul>
&lt;h6 id="conclusion-3">Conclusion&lt;/h6>
&lt;ul>
&lt;li>In the FS scenario, HugeGraph outperforms Neo4j and Titan in terms of performance.&lt;/li>
&lt;li>In the K-neighbor and K-out scenarios, HugeGraph can achieve results returned within seconds within 5 degrees.&lt;/li>
&lt;/ul>
&lt;h4 id="24-comprehensive-performance-test---cw">2.4 Comprehensive Performance Test - CW&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Database&lt;/th>
&lt;th>Size 1000&lt;/th>
&lt;th>Size 5000&lt;/th>
&lt;th>Size 10000&lt;/th>
&lt;th>Size 20000&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>HugeGraph(core)&lt;/td>
&lt;td>20.804&lt;/td>
&lt;td>242.099&lt;/td>
&lt;td>744.780&lt;/td>
&lt;td>1700.547&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Titan&lt;/td>
&lt;td>45.790&lt;/td>
&lt;td>820.633&lt;/td>
&lt;td>2652.235&lt;/td>
&lt;td>9568.623&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Neo4j&lt;/td>
&lt;td>5.913&lt;/td>
&lt;td>50.267&lt;/td>
&lt;td>142.354&lt;/td>
&lt;td>460.880&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Explanation&lt;/em>&lt;/p>
&lt;ul>
&lt;li>The &amp;ldquo;scale&amp;rdquo; is based on the number of vertices.&lt;/li>
&lt;li>The data in the table is the time required to complete community discovery, in seconds. For example, if HugeGraph uses the RocksDB backend and operates on a dataset of 10,000 vertices, and the community aggregation is no longer changing, it takes 744.780 seconds.&lt;/li>
&lt;li>The CW test is a comprehensive evaluation of CRUD operations.&lt;/li>
&lt;li>In this test, HugeGraph, like Titan, did not use the client and directly operated on the core.&lt;/li>
&lt;/ul>
&lt;h5 id="conclusion-4">Conclusion&lt;/h5>
&lt;ul>
&lt;li>Performance of community detection algorithm: Neo4j &amp;gt; HugeGraph &amp;gt; Titan&lt;/li>
&lt;/ul></description></item><item><title>Docs: HugeGraph-API Performance</title><link>/docs/performance/api-preformance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/performance/api-preformance/</guid><description>
&lt;p>The HugeGraph API performance test mainly tests HugeGraph-Server&amp;rsquo;s ability to concurrently process RESTful API requests, including:&lt;/p>
&lt;ul>
&lt;li>Single insertion of vertices/edges&lt;/li>
&lt;li>Batch insertion of vertices/edges&lt;/li>
&lt;li>Vertex/Edge Queries&lt;/li>
&lt;/ul>
&lt;p>For the performance test of the RESTful API of each release version of HugeGraph, please refer to:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="/docs/performance/api-preformance/hugegraph-api-0.5.6-rocksdb/">v0.5.6 stand-alone&lt;/a>&lt;/li>
&lt;li>&lt;a href="/docs/performance/api-preformance/hugegraph-api-0.5.6-cassandra/">v0.5.6 cluster&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Updates coming soon, stay tuned!&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: HugeGraph-Loader Performance</title><link>/docs/performance/hugegraph-loader-performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/performance/hugegraph-loader-performance/</guid><description>
&lt;h2 id="use-cases">Use Cases&lt;/h2>
&lt;p>When the number of graph data to be batch inserted (including vertices and edges) is at the billion level or below, or the total data size is less than TB, the &lt;a href="/docs/quickstart/hugegraph-loader">HugeGraph-Loader&lt;/a> tool can be used to continuously and quickly import graph data.&lt;/p>
&lt;h2 id="performance">Performance&lt;/h2>
&lt;blockquote>
&lt;p>The test uses the edge data of website.&lt;/p>
&lt;/blockquote>
&lt;h3 id="rocksdb-single-machine-performance">RocksDB single-machine performance&lt;/h3>
&lt;ul>
&lt;li>When label index is turned off, 228k edges/s.&lt;/li>
&lt;li>When label index is turned on, 153k edges/s.&lt;/li>
&lt;/ul>
&lt;h3 id="cassandra-cluster-performance">Cassandra cluster performance&lt;/h3>
&lt;ul>
&lt;li>When label index is turned on by default, 63k edges/s.&lt;/li>
&lt;/ul></description></item><item><title>Docs:</title><link>/docs/performance/hugegraph-benchmark-0.4.4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/performance/hugegraph-benchmark-0.4.4/</guid><description>
&lt;h3 id="1-测试环境">1 测试环境&lt;/h3>
&lt;h4 id="11-硬件信息">1.1 硬件信息&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>CPU&lt;/th>
&lt;th>Memory&lt;/th>
&lt;th>网卡&lt;/th>
&lt;th>磁盘&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>48 Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz&lt;/td>
&lt;td>128G&lt;/td>
&lt;td>10000Mbps&lt;/td>
&lt;td>750GB SSD&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="12-软件信息">1.2 软件信息&lt;/h4>
&lt;h5 id="121-测试用例">1.2.1 测试用例&lt;/h5>
&lt;p>测试使用&lt;a href="https://github.com/socialsensor/graphdb-benchmarks">graphdb-benchmark&lt;/a>，一个图数据库测试集。该测试集主要包含4类测试：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Massive Insertion，批量插入顶点和边，一定数量的顶点或边一次性提交&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Single Insertion，单条插入，每个顶点或者每条边立即提交&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Query，主要是图数据库的基本查询操作：&lt;/p>
&lt;ul>
&lt;li>Find Neighbors，查询所有顶点的邻居&lt;/li>
&lt;li>Find Adjacent Nodes，查询所有边的邻接顶点&lt;/li>
&lt;li>Find Shortest Path，查询第一个顶点到100个随机顶点的最短路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Clustering，基于Louvain Method的社区发现算法&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="122-测试数据集">1.2.2 测试数据集&lt;/h5>
&lt;p>测试使用人造数据和真实数据&lt;/p>
&lt;ul>
&lt;li>
&lt;p>MIW、SIW和QW使用SNAP数据集&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="http://snap.stanford.edu/data/email-Enron.html">Enron Dataset&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://snap.stanford.edu/data/amazon0601.html">Amazon dataset&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://snap.stanford.edu/data/com-Youtube.html">Youtube dataset&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://snap.stanford.edu/data/com-LiveJournal.html">LiveJournal dataset&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>CW使用&lt;a href="https://sites.google.com/site/andrealancichinetti/files">LFR-Benchmark generator&lt;/a>生成的人造数据&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h6 id="本测试用到的数据集规模">本测试用到的数据集规模&lt;/h6>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名称&lt;/th>
&lt;th>vertex数目&lt;/th>
&lt;th>edge数目&lt;/th>
&lt;th>文件大小&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>email-enron.txt&lt;/td>
&lt;td>36,691&lt;/td>
&lt;td>367,661&lt;/td>
&lt;td>4MB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>com-youtube.ungraph.txt&lt;/td>
&lt;td>1,157,806&lt;/td>
&lt;td>2,987,624&lt;/td>
&lt;td>38.7MB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>amazon0601.txt&lt;/td>
&lt;td>403,393&lt;/td>
&lt;td>3,387,388&lt;/td>
&lt;td>47.9MB&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="13-服务配置">1.3 服务配置&lt;/h4>
&lt;ul>
&lt;li>HugeGraph版本：0.4.4，RestServer和Gremlin Server和backends都在同一台服务器上&lt;/li>
&lt;li>Cassandra版本：cassandra-3.10，commit-log 和data共用SSD&lt;/li>
&lt;li>RocksDB版本：rocksdbjni-5.8.6&lt;/li>
&lt;li>Titan版本：0.5.4, 使用thrift+Cassandra模式&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>graphdb-benchmark适配的Titan版本为0.5.4&lt;/p>
&lt;/blockquote>
&lt;h3 id="2-测试结果">2 测试结果&lt;/h3>
&lt;h4 id="21-batch插入性能">2.1 Batch插入性能&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Backend&lt;/th>
&lt;th>email-enron(30w)&lt;/th>
&lt;th>amazon0601(300w)&lt;/th>
&lt;th>com-youtube.ungraph(300w)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Titan&lt;/td>
&lt;td>9.516&lt;/td>
&lt;td>88.123&lt;/td>
&lt;td>111.586&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RocksDB&lt;/td>
&lt;td>2.345&lt;/td>
&lt;td>14.076&lt;/td>
&lt;td>16.636&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Cassandra&lt;/td>
&lt;td>11.930&lt;/td>
&lt;td>108.709&lt;/td>
&lt;td>101.959&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Memory&lt;/td>
&lt;td>3.077&lt;/td>
&lt;td>15.204&lt;/td>
&lt;td>13.841&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>说明&lt;/em>&lt;/p>
&lt;ul>
&lt;li>表头&amp;quot;（）&amp;ldquo;中数据是数据规模，以边为单位&lt;/li>
&lt;li>表中数据是批量插入的时间，单位是s&lt;/li>
&lt;li>例如，HugeGraph使用RocksDB插入amazon0601数据集的300w条边，花费14.076s，速度约为21w edges/s&lt;/li>
&lt;/ul>
&lt;h5 id="结论">结论&lt;/h5>
&lt;ul>
&lt;li>RocksDB和Memory后端插入性能优于Cassandra&lt;/li>
&lt;li>HugeGraph和Titan同样使用Cassandra作为后端的情况下，插入性能接近&lt;/li>
&lt;/ul>
&lt;h4 id="22-遍历性能">2.2 遍历性能&lt;/h4>
&lt;h5 id="221-术语说明">2.2.1 术语说明&lt;/h5>
&lt;ul>
&lt;li>FN(Find Neighbor), 遍历所有vertex, 根据vertex查邻接edge, 通过edge和vertex查other vertex&lt;/li>
&lt;li>FA(Find Adjacent), 遍历所有edge，根据edge获得source vertex和target vertex&lt;/li>
&lt;/ul>
&lt;h5 id="222-fn性能">2.2.2 FN性能&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Backend&lt;/th>
&lt;th>email-enron(3.6w)&lt;/th>
&lt;th>amazon0601(40w)&lt;/th>
&lt;th>com-youtube.ungraph(120w)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Titan&lt;/td>
&lt;td>7.724&lt;/td>
&lt;td>70.935&lt;/td>
&lt;td>128.884&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RocksDB&lt;/td>
&lt;td>8.876&lt;/td>
&lt;td>65.852&lt;/td>
&lt;td>63.388&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Cassandra&lt;/td>
&lt;td>13.125&lt;/td>
&lt;td>126.959&lt;/td>
&lt;td>102.580&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Memory&lt;/td>
&lt;td>22.309&lt;/td>
&lt;td>207.411&lt;/td>
&lt;td>165.609&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>说明&lt;/em>&lt;/p>
&lt;ul>
&lt;li>表头&amp;rdquo;（）&amp;ldquo;中数据是数据规模，以顶点为单位&lt;/li>
&lt;li>表中数据是遍历顶点花费的时间，单位是s&lt;/li>
&lt;li>例如，HugeGraph使用RocksDB后端遍历amazon0601的所有顶点，并查找邻接边和另一顶点，总共耗时65.852s&lt;/li>
&lt;/ul>
&lt;h5 id="223-fa性能">2.2.3 FA性能&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Backend&lt;/th>
&lt;th>email-enron(30w)&lt;/th>
&lt;th>amazon0601(300w)&lt;/th>
&lt;th>com-youtube.ungraph(300w)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Titan&lt;/td>
&lt;td>7.119&lt;/td>
&lt;td>63.353&lt;/td>
&lt;td>115.633&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RocksDB&lt;/td>
&lt;td>6.032&lt;/td>
&lt;td>64.526&lt;/td>
&lt;td>52.721&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Cassandra&lt;/td>
&lt;td>9.410&lt;/td>
&lt;td>102.766&lt;/td>
&lt;td>94.197&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Memory&lt;/td>
&lt;td>12.340&lt;/td>
&lt;td>195.444&lt;/td>
&lt;td>140.89&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>说明&lt;/em>&lt;/p>
&lt;ul>
&lt;li>表头&amp;rdquo;（）&amp;ldquo;中数据是数据规模，以边为单位&lt;/li>
&lt;li>表中数据是遍历边花费的时间，单位是s&lt;/li>
&lt;li>例如，HugeGraph使用RocksDB后端遍历amazon0601的所有边，并查询每条边的两个顶点，总共耗时64.526s&lt;/li>
&lt;/ul>
&lt;h6 id="结论-1">结论&lt;/h6>
&lt;ul>
&lt;li>HugeGraph RocksDB &amp;gt; Titan thrift+Cassandra &amp;gt; HugeGraph Cassandra &amp;gt; HugeGraph Memory&lt;/li>
&lt;/ul>
&lt;h4 id="23-hugegraph-图常用分析方法性能">2.3 HugeGraph-图常用分析方法性能&lt;/h4>
&lt;h5 id="术语说明">术语说明&lt;/h5>
&lt;ul>
&lt;li>FS(Find Shortest Path), 寻找最短路径&lt;/li>
&lt;li>K-neighbor，从起始vertex出发，通过K跳边能够到达的所有顶点, 包括1, 2, 3&amp;hellip;(K-1), K跳边可达vertex&lt;/li>
&lt;li>K-out, 从起始vertex出发，恰好经过K跳out边能够到达的顶点&lt;/li>
&lt;/ul>
&lt;h5 id="fs性能">FS性能&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Backend&lt;/th>
&lt;th>email-enron(30w)&lt;/th>
&lt;th>amazon0601(300w)&lt;/th>
&lt;th>com-youtube.ungraph(300w)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Titan&lt;/td>
&lt;td>11.333&lt;/td>
&lt;td>0.313&lt;/td>
&lt;td>376.06&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RocksDB&lt;/td>
&lt;td>44.391&lt;/td>
&lt;td>2.221&lt;/td>
&lt;td>268.792&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Cassandra&lt;/td>
&lt;td>39.845&lt;/td>
&lt;td>3.337&lt;/td>
&lt;td>331.113&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Memory&lt;/td>
&lt;td>35.638&lt;/td>
&lt;td>2.059&lt;/td>
&lt;td>388.987&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>说明&lt;/em>&lt;/p>
&lt;ul>
&lt;li>表头&amp;rdquo;（）&amp;ldquo;中数据是数据规模，以边为单位&lt;/li>
&lt;li>表中数据是找到&lt;strong>从第一个顶点出发到达随机选择的100个顶点的最短路径&lt;/strong>的时间，单位是s&lt;/li>
&lt;li>例如，HugeGraph使用RocksDB查找第一个顶点到100个随机顶点的最短路径，总共耗时2.059s&lt;/li>
&lt;/ul>
&lt;h6 id="结论-2">结论&lt;/h6>
&lt;ul>
&lt;li>在数据规模小或者顶点关联关系少的场景下，Titan最短路径性能优于HugeGraph&lt;/li>
&lt;li>随着数据规模增大且顶点的关联度增高，HugeGraph最短路径性能优于Titan&lt;/li>
&lt;/ul>
&lt;h5 id="k-neighbor性能">K-neighbor性能&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>顶点&lt;/th>
&lt;th>深度&lt;/th>
&lt;th>一度&lt;/th>
&lt;th>二度&lt;/th>
&lt;th>三度&lt;/th>
&lt;th>四度&lt;/th>
&lt;th>五度&lt;/th>
&lt;th>六度&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>v1&lt;/td>
&lt;td>时间&lt;/td>
&lt;td>0.031s&lt;/td>
&lt;td>0.033s&lt;/td>
&lt;td>0.048s&lt;/td>
&lt;td>0.500s&lt;/td>
&lt;td>11.27s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>v111&lt;/td>
&lt;td>时间&lt;/td>
&lt;td>0.027s&lt;/td>
&lt;td>0.034s&lt;/td>
&lt;td>0.115&lt;/td>
&lt;td>1.36s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;td>&amp;ndash;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>v1111&lt;/td>
&lt;td>时间&lt;/td>
&lt;td>0.039s&lt;/td>
&lt;td>0.027s&lt;/td>
&lt;td>0.052s&lt;/td>
&lt;td>0.511s&lt;/td>
&lt;td>10.96s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>说明&lt;/em>&lt;/p>
&lt;ul>
&lt;li>HugeGraph-Server的JVM内存设置为32GB，数据量过大时会出现OOM&lt;/li>
&lt;/ul>
&lt;h5 id="k-out性能">K-out性能&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>顶点&lt;/th>
&lt;th>深度&lt;/th>
&lt;th>一度&lt;/th>
&lt;th>二度&lt;/th>
&lt;th>三度&lt;/th>
&lt;th>四度&lt;/th>
&lt;th>五度&lt;/th>
&lt;th>六度&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>v1&lt;/td>
&lt;td>时间&lt;/td>
&lt;td>0.054s&lt;/td>
&lt;td>0.057s&lt;/td>
&lt;td>0.109s&lt;/td>
&lt;td>0.526s&lt;/td>
&lt;td>3.77s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>度&lt;/td>
&lt;td>10&lt;/td>
&lt;td>133&lt;/td>
&lt;td>2453&lt;/td>
&lt;td>50,830&lt;/td>
&lt;td>1,128,688&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>v111&lt;/td>
&lt;td>时间&lt;/td>
&lt;td>0.032s&lt;/td>
&lt;td>0.042s&lt;/td>
&lt;td>0.136s&lt;/td>
&lt;td>1.25s&lt;/td>
&lt;td>20.62s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>度&lt;/td>
&lt;td>10&lt;/td>
&lt;td>211&lt;/td>
&lt;td>4944&lt;/td>
&lt;td>113150&lt;/td>
&lt;td>2,629,970&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>v1111&lt;/td>
&lt;td>时间&lt;/td>
&lt;td>0.039s&lt;/td>
&lt;td>0.045s&lt;/td>
&lt;td>0.053s&lt;/td>
&lt;td>1.10s&lt;/td>
&lt;td>2.92s&lt;/td>
&lt;td>OOM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>度&lt;/td>
&lt;td>10&lt;/td>
&lt;td>140&lt;/td>
&lt;td>2555&lt;/td>
&lt;td>50825&lt;/td>
&lt;td>1,070,230&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>说明&lt;/em>&lt;/p>
&lt;ul>
&lt;li>HugeGraph-Server的JVM内存设置为32GB，数据量过大时会出现OOM&lt;/li>
&lt;/ul>
&lt;h6 id="结论-3">结论&lt;/h6>
&lt;ul>
&lt;li>FS场景，HugeGraph性能优于Titan&lt;/li>
&lt;li>K-neighbor和K-out场景，HugeGraph能够实现在5度范围内秒级返回结果&lt;/li>
&lt;/ul>
&lt;h4 id="24-图综合性能测试-cw">2.4 图综合性能测试-CW&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数据库&lt;/th>
&lt;th>规模1000&lt;/th>
&lt;th>规模5000&lt;/th>
&lt;th>规模10000&lt;/th>
&lt;th>规模20000&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Titan&lt;/td>
&lt;td>45.943&lt;/td>
&lt;td>849.168&lt;/td>
&lt;td>2737.117&lt;/td>
&lt;td>9791.46&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Memory(core)&lt;/td>
&lt;td>41.077&lt;/td>
&lt;td>1825.905&lt;/td>
&lt;td>*&lt;/td>
&lt;td>*&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Cassandra（core）&lt;/td>
&lt;td>39.783&lt;/td>
&lt;td>862.744&lt;/td>
&lt;td>2423.136&lt;/td>
&lt;td>6564.191&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RocksDB（core）&lt;/td>
&lt;td>33.383&lt;/td>
&lt;td>199.894&lt;/td>
&lt;td>763.869&lt;/td>
&lt;td>1677.813&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>说明&lt;/em>&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;规模&amp;quot;以顶点为单位&lt;/li>
&lt;li>表中数据是社区发现完成需要的时间，单位是s，例如HugeGraph使用RocksDB后端在规模10000的数据集，社区聚合不再变化，需要耗时763.869s&lt;/li>
&lt;li>&amp;ldquo;*&amp;ldquo;表示超过10000s未完成&lt;/li>
&lt;li>CW测试是CRUD的综合评估&lt;/li>
&lt;li>后三者分别是HugeGraph的不同后端，该测试中HugeGraph跟Titan一样，没有通过client，直接对core操作&lt;/li>
&lt;/ul>
&lt;h5 id="结论-4">结论&lt;/h5>
&lt;ul>
&lt;li>HugeGraph在使用Cassandra后端时，性能略优于Titan，随着数据规模的增大，优势越来越明显，数据规模20000时，比Titan快30%&lt;/li>
&lt;li>HugeGraph在使用RocksDB后端时，性能远高于Titan和HugeGraph的Cassandra后端，分别比两者快了6倍和4倍&lt;/li>
&lt;/ul></description></item></channel></rss>